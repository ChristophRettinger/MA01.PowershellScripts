
    $connection.Open()
    $reader = $command.ExecuteReader()
    if ($reader.Read()) {
        $min = $reader['CL_ID_BIG_Min']
        $max = $reader['CL_ID_BIG_Max']
        $count = $reader['RecordCount']

        # Display the output in the requested format
        Write-Output "Anstalt Min Max Count"
        Write-Output "$Anstalt $min $max $count"
    } else {
        Write-Warning 'Query returned no rows.'
    }
    $reader.Close()
    $connection.Close()
}
catch {
    Write-Error "Failed to query database: $_"
}

# Elasticsearch comparison logic
try {
    # Load mapping CSV
    if (-not (Test-Path -Path $MappingCsvPath)) {
        Write-Warning "Mapping CSV not found at '$MappingCsvPath'. Skipping Elasticsearch query."
        return
    }

    $mappings = Import-Csv -Path $MappingCsvPath
    $mapping = $mappings | Where-Object { $_.Anstalt -eq "$Anstalt" -and $_.DatabaseName -eq $DatabaseName }
    if (-not $mapping) {
        Write-Warning "No mapping found for Anstalt '$Anstalt' and DatabaseName '$DatabaseName'. Skipping Elasticsearch query."
        return
    }

    $elasticName = $mapping.ElasticName

    # Build Elasticsearch query body
    $filters = @()
    # Filter by database name mapping
    $filters += @{ term = @{ 'BK.SUBFL_sourcedb.keyword' = $elasticName } }

    # Time range filter if provided
    $range = @{ gte = $StartDate.ToString('o') }
    if ($includeEndDate) {
        $range.lte = $EndDate.ToString('o')
    }
    $filters += @{ range = @{ $ElasticTimeField = $range } }

    $esBody = @{ 
        size = 0
        query = @{ bool = @{ filter = $filters } }
        aggs = @{ 
            min_id = @{ min = @{ field = 'BK.SUBFL_sourceid' } }
            max_id = @{ max = @{ field = 'BK.SUBFL_sourceid' } }
            count_id = @{ value_count = @{ field = 'BK.SUBFL_sourceid' } }
        }
    } | ConvertTo-Json -Depth 8

    # Resolve API key and set Authorization header
    $apiKey = $null
    if ($PSBoundParameters.ContainsKey('ElasticApiKey') -and $ElasticApiKey) {
        $apiKey = $ElasticApiKey.Trim()
    } elseif ($PSBoundParameters.ContainsKey('ElasticApiKeyPath') -and $ElasticApiKeyPath) {
        if (-not (Test-Path -Path $ElasticApiKeyPath)) {
            Write-Warning "ElasticApiKeyPath '$ElasticApiKeyPath' not found. Skipping Elasticsearch query."
            return
        }
        $apiKey = (Get-Content -Path $ElasticApiKeyPath -Raw).Trim()
    }

    if (-not $apiKey) {
        Write-Warning 'No Elasticsearch API key provided. Provide -ElasticApiKey or -ElasticApiKeyPath to enable ES query.'
        return
    }

    $headers = @{ 'Content-Type' = 'application/json'; 'Authorization' = "ApiKey $apiKey" }

    $esResponse = Invoke-RestMethod -Method Post -Uri $ElasticUrl -Headers $headers -Body $esBody -TimeoutSec 120

    $esMin = $null
    $esMax = $null
    $esCount = $null
    if ($esResponse.aggregations) {
        $esMin = $esResponse.aggregations.min_id.value
        $esMax = $esResponse.aggregations.max_id.value
        $esCount = $esResponse.aggregations.count_id.value
    } elseif ($esResponse.hits) {
        # Fallback: no aggs returned
        $esCount = $esResponse.hits.total.value
    }

    Write-Output ''
    Write-Output 'Elasticsearch Min Max Count'
    Write-Output "$Anstalt $esMin $esMax $esCount"
}
catch {
    Write-Warning "Elasticsearch query failed: $_"
}
